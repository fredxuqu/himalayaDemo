chap01. 并发编程的挑战
	1.	多线程编程的目的

	2. 多线程编程所要面对的问题
		a.	如何减少上下文切换的次数
			无锁并发编程：避免使用锁，如按ID分段，不同的线程处理不同段的数据
			CAS算法：使用CAS算法来更新数据
			使用最少线程：避免创建不需要的线程，避免大量线程都处在等待状态
			使用协程： 在单线程里面实现多任务调度，并在单线程里维持多个任务间的切换
		b.	如何分析
			使用jstack命令dump线程信息
			sudo -u admin /opt/ifeve/java/bin/jstack 19786 > /home/anna/dump17
			
			统计所有线程都在干什么
			grep java.lang.Thread.State dump17 | awk '{print $2$3$4$5}' | sort | uniq -c
			
			打开dump文件查看处于waiting状态的线程都在做什么
			最后根据查看的结果调整系统的参数，降低或者增加线程的数量
			
		c.	死锁的分析
			查看dump信息
			
			java.lang.Thread.State: BLOCKED
			
			避免在同一个线程中同时获取多个锁
			避免在一个线程内同时占用多个资源，尽量保证每个锁只占用一个资源
			使用ReenterLock来替代内部锁机制
			对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。
			
		d. 资源限制的挑战
			在并发编程时，程序的执行效率受限于计算机硬件的资源或软件资源，如带宽、数据库连接数和socket连接数等。
			
			如果是硬件资源限制，可以考虑使用集群并行执行程序
			如果是软件资源限制，则可以考虑使用资源池，将资源重复利用
		
chap02.	java并发机制的底层实现原理
	volatile关键字的应用
	在多处理器开发中保证了共享变量的“可见性”，java线程内存模型确保所有线程看到这个变量的值是一致的。
	
	定义与实现原理
	
	由volatile修饰的汇编代码：
		0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);
	Lock前缀的指令在多核处理器下会引发了两件事情：
	1）将当前处理器缓存行的数据写回到系统内存。
	2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。
	
	原子操作的实现原理
	
	
	
	